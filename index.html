<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GIF ➜ Lottie JSON (Auto/Manual Frames, Final)</title>
<style>
  :root { color-scheme: dark; }
  body { background:#121212; color:#e0e0e0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; padding:2rem; display:flex; justify-content:center; }
  .card { width:min(980px, 96vw); background:#1e1e1e; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.45); padding:22px; }
  h2 { margin:.25rem 0 1rem; color:#fafafa }
  h3 { margin:.5rem 0 .6rem }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center }
  .section { margin:1rem 0 }
  input[type="text"], input[type="number"], select { background:#2a2a2a; color:#fff; border:1px solid #444; border-radius:8px; padding:.48rem .6rem; font-size:15px; }
  button { background:#2196f3; color:#fff; border:0; border-radius:10px; padding:.6rem 1.1rem; font-weight:600; cursor:pointer; }
  button:disabled { background:#555; cursor:not-allowed }
  button:hover:not(:disabled) { background:#1976d2 }
  .preview { border:1px solid #333; border-radius:10px; height:380px; background:#121212; }
  .hint { color:#aaa; font-size:.92rem }
  .danger { color:#ff7676 }
  progress { width:260px; height:10px }
  .kv { display:inline-block; min-width:120px; color:#bbb }
  .pill { padding:.2rem .6rem; border:1px solid #444; border-radius:999px; font-size:.85rem; color:#bbb; }
  .stats { display:flex; gap:16px; flex-wrap:wrap; margin-top:.25rem; }
  .stat { background:#222; border:1px solid #333; border-radius:10px; padding:.4rem .7rem; font-size:.92rem; color:#cfcfcf }
  .subtle { color:#9aa; font-size:.9rem }
  .disabled { opacity:.6; pointer-events:none; }
</style>
</head>
<body>
  <div class="card">
    <h2>GIF ➜ Lottie JSON (Single File, Auto/Manual Frames)</h2>

    <div class="section row">
      <input id="fileInput" type="file" accept=".gif" />
      <input id="baseName" type="text" value="animation" placeholder="Base filename" />
      <button id="convertBtn" disabled>Convert to JSON</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div class="section">
      <h3>Detected GIF</h3>
      <div id="status" class="hint">Load a GIF to begin.</div>
      <div class="stats" id="gifStats" style="display:none">
        <div class="stat">Frames: <span id="statFrames">—</span></div>
        <div class="stat">Duration: <span id="statDuration">—</span></div>
        <div class="stat">Inferred FPS: <span id="statFps">—</span></div>
        <div class="stat">Size: <span id="statSize">—</span></div>
      </div>
    </div>

    <div class="section">
      <h3>Frame Strategy</h3>
      <div class="row">
        <label>Mode
          <select id="frameMode">
            <option value="auto" selected>Auto (smart cap)</option>
            <option value="max">Limit by Max Frames</option>
            <option value="fps">Limit by Target FPS</option>
            <option value="step">Keep every Nth frame</option>
          </select>
        </label>

        <label id="maxFramesWrap">Max Frames
          <input type="number" id="maxFrames" value="300" min="50" step="10" style="width:6rem" />
        </label>

        <label id="targetFpsWrap" class="disabled">Target FPS
          <input type="number" id="targetFps" value="20" min="2" max="60" step="1" style="width:6rem" />
        </label>

        <label id="keepNthWrap" class="disabled">Keep every Nth
          <input type="number" id="keepNth" value="2" min="2" step="1" style="width:6rem" />
        </label>

        <span class="pill">Auto chooses a cap based on duration & frames (aims ≤ 300)</span>
      </div>
    </div>

    <div class="section">
      <h3>Output</h3>
      <div class="row">
        <label>Embedded Format
          <select id="embedFormat">
            <option value="webp" selected>WebP (smaller JSON)</option>
            <option value="png">PNG (bigger, max compatibility)</option>
          </select>
        </label>
        <label>WebP Quality
          <input type="number" id="webpQ" value="0.7" min="0" max="1" step="0.05" style="width:6rem" />
        </label>
        <label>Target Size (KB)
          <input type="number" id="targetKB" value="900" min="0" step="50" style="width:7rem" />
        </label>
        <span class="pill">>0 auto-tunes WebP to hit target</span>
      </div>

      <div class="row">
        <label>Max Width <input type="number" id="maxW" value="512" min="16" style="width:6rem" /></label>
        <label>Max Height <input type="number" id="maxH" value="512" min="16" style="width:6rem" /></label>
      </div>

      <div class="row">
        <label><input type="checkbox" id="useQuant" checked /> Quantize colors before encode</label>
        <label><input type="checkbox" id="removeBlack" /> Remove black background</label>
        <label>Threshold <input type="number" id="blackThresh" value="8" min="0" max="64" style="width:5rem" /></label>
        <span class="pill">Use low threshold (4–10) for cleaner edges</span>
      </div>

      <div class="row" id="progressWrap" style="display:none">
        <span class="kv" id="progLabel">Encoding…</span>
        <progress id="prog" max="100" value="0"></progress>
        <span class="kv" id="progDetail"></span>
      </div>
    </div>

    <div class="section">
      <h3 style="margin:.25rem 0 .5rem">Preview</h3>
      <div id="lottieContainer" class="preview"></div>
      <div class="hint">Live preview of the generated JSON (same data you download).</div>
      <div class="subtle" id="resultNote"></div>
    </div>
  </div>

<script type="module">
import { parseGIF, decompressFrames } from 'https://esm.sh/gifuct-js@2.1.2';
import lottie from 'https://esm.sh/lottie-web';
import * as IQ from 'https://esm.sh/image-q@4.0.0';

/* ---------- Elements ---------- */
const $ = id => document.getElementById(id);
const fileInput   = $('fileInput');
const baseName    = $('baseName');
const convertBtn  = $('convertBtn');
const resetBtn    = $('resetBtn');
const lottieDiv   = $('lottieContainer');
const statusEl    = $('status');
const resultNote  = $('resultNote');

const statFrames  = $('statFrames');
const statDuration= $('statDuration');
const statFps     = $('statFps');
const statSize    = $('statSize');
const gifStats    = $('gifStats');

const frameMode   = $('frameMode');
const maxFrames   = $('maxFrames');
const targetFps   = $('targetFps');
const keepNth     = $('keepNth');
const maxFramesWrap= $('maxFramesWrap');
const targetFpsWrap=$('targetFpsWrap');
const keepNthWrap = $('keepNthWrap');

const embedFormat = $('embedFormat');
const webpQ       = $('webpQ');
const targetKB    = $('targetKB');
const maxW        = $('maxW');
const maxH        = $('maxH');
const useQuant    = $('useQuant');
const removeBlack = $('removeBlack');
const blackThresh = $('blackThresh');

const progWrap    = $('progressWrap');
const prog        = $('prog');
const progLabel   = $('progLabel');
const progDetail  = $('progDetail');

/* ---------- State ---------- */
let gifFrames = null;
let parsedGif = null;
let gifW = 0, gifH = 0;
let lottiePlayer = null;
let origBytes = 0;

/* ---------- UI helpers ---------- */
function setStatus(msg, isError=false){
  statusEl.textContent = msg;
  statusEl.className = isError ? 'hint danger' : 'hint';
}
function resetPreview(){
  lottieDiv.innerHTML = '';
  resultNote.textContent = '';
  if (lottiePlayer) { try { lottiePlayer.destroy(); } catch(_){} lottiePlayer = null; }
}
function resetAll(){
  gifFrames = null; parsedGif = null; gifW=0; gifH=0; origBytes = 0;
  convertBtn.disabled = true;
  setStatus('Load a GIF to begin.');
  resetPreview();
  fileInput.value = '';
  showProgress(false);
  gifStats.style.display = 'none';
}
resetBtn.addEventListener('click', resetAll);

function showProgress(show, label='', val=0, detail=''){
  progWrap.style.display = show ? 'flex' : 'none';
  if (show){ prog.value = val; progLabel.textContent = label || 'Encoding…'; progDetail.textContent = detail || ''; }
}

/* ---------- Frame Mode UI enable/disable ---------- */
function syncFrameModeUI(){
  const mode = frameMode.value;
  maxFramesWrap.classList.toggle('disabled', !(mode === 'auto' || mode === 'max'));
  targetFpsWrap.classList.toggle('disabled', mode !== 'fps');
  keepNthWrap.classList.toggle('disabled', mode !== 'step');
}
frameMode.addEventListener('change', syncFrameModeUI);
syncFrameModeUI();

/* ---------- Load GIF ---------- */
fileInput.addEventListener('change', async () => {
  resetPreview();
  const f = fileInput.files?.[0];
  if (!f) return;
  origBytes = f.size;
  if (f.size > 100 * 1024 * 1024) {
    setStatus('File too large (max 100 MB).', true);
    fileInput.value = '';
    return;
  }
  try {
    setStatus('Parsing GIF…');
    const buf = await f.arrayBuffer();
    parsedGif = parseGIF(buf);
    gifFrames = decompressFrames(parsedGif, true);
    gifW = parsedGif.lsd.width;
    gifH = parsedGif.lsd.height;
    convertBtn.disabled = !gifFrames?.length;

    // Detected stats
    const delays = gifFrames.map(fr => (fr.delay || 10) * 10);
    const totalMs = delays.reduce((a,b)=>a+b, 0);
    const fps = totalMs > 0 ? (gifFrames.length / (totalMs/1000)) : 0;

    statFrames.textContent   = gifFrames.length.toString();
    statDuration.textContent = `${(totalMs/1000).toFixed(2)} s`;
    statFps.textContent      = fps ? fps.toFixed(2) : '—';
    statSize.textContent     = `${(origBytes/1024/1024).toFixed(2)} MB`;
    gifStats.style.display   = 'flex';

    // Auto suggest max frames based on duration & total frames (aim ≤ 300)
    // For long clips, try to keep ~20 fps * duration but clamp to 300
    const desired = Math.min(300, Math.max(120, Math.round((totalMs/1000) * 20)));
    maxFrames.value = Math.min(desired, 300);

    setStatus(`Loaded ${gifFrames.length} frames @ ${gifW}×${gifH}. Choose strategy and convert.`);
  } catch (e) {
    console.error(e);
    setStatus('Failed to read GIF. Is the file valid?', true);
    convertBtn.disabled = true;
  }
});

/* ---------- Convert ---------- */
convertBtn.addEventListener('click', async () => {
  if (!gifFrames?.length) return;
  convertBtn.disabled = true;
  setStatus('Converting to JSON…');
  showProgress(true, 'Preprocessing…', 0);

  try {
    const json = await gifToLottieSingleJSON(gifFrames, {
      logicalW: gifW, logicalH: gifH,
      maxW: parseInt(maxW.value,10) || 4096,
      maxH: parseInt(maxH.value,10) || 4096,
      frameMode: frameMode.value,
      maxFrames: Math.max(50, parseInt(maxFrames.value,10) || 300),
      targetFps: Math.max(2, Math.min(60, parseInt(targetFps.value,10) || 20)),
      keepNth: Math.max(2, parseInt(keepNth.value,10) || 2),
      format: embedFormat.value, // 'webp' | 'png'
      webpQ: Math.max(0, Math.min(1, parseFloat(webpQ.value))),
      targetKB: Math.max(0, parseInt(targetKB.value,10) || 0),
      quantize: !!useQuant.checked,
      removeBlack: !!removeBlack.checked,
      blackThresh: parseInt(blackThresh.value,10) || 0,
      onProgress: (stage, i, total) => {
        if (stage === 'compose') showProgress(true, 'Compositing frames…', Math.round((i/total)*15), `${i}/${total}`);
        if (stage === 'resize')  showProgress(true, 'Resizing frames…',     15 + Math.round((i/total)*15), `${i}/${total}`);
        if (stage === 'dedupe')  showProgress(true, 'Deduplicating…',       30);
        if (stage === 'cap')     showProgress(true, 'Capping frames…',      35);
        if (stage === 'quant')   showProgress(true, 'Quantizing colors…',   40 + Math.round((i/total)*20), `${i}/${total}`);
        if (stage === 'encode')  showProgress(true, 'Encoding images…',     60 + Math.round((i/total)*35), `${i}/${total}`);
        if (stage === 'assemble')showProgress(true, 'Assembling JSON…',     95);
      }
    });

    // Preview (canvas renderer = sharper)
    resetPreview();
    lottiePlayer = lottie.loadAnimation({
      container: lottieDiv,
      renderer: 'canvas',
      loop: true,
      autoplay: true,
      animationData: json
    });

    // Download
    const name = (baseName.value || 'animation') + '.json';
    const str  = JSON.stringify(json, null, 2);
    const blob = new Blob([str], { type:'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    document.body.appendChild(a); a.click(); a.remove();

    const prettySizeKB = (str.length/1024).toFixed(0);
    resultNote.textContent = `Original GIF: ${(origBytes/1024/1024).toFixed(2)} MB • JSON: ${prettySizeKB} KB • Layers: ${json.layers.length}`;
    setStatus(`Done. JSON ~ ${prettySizeKB} KB. Previewing and downloaded.`);
  } catch (e) {
    console.error(e);
    setStatus('Conversion failed. See console for details.', true);
  } finally {
    convertBtn.disabled = false;
    showProgress(false);
  }
});

/* ---------- Core conversion pipeline ---------- */

// Compose frames to full logical canvas with disposal handling
function composeGifFramesToCanvases(frames, logicalW, logicalH, onProgress){
  const comp = document.createElement('canvas'); comp.width = logicalW; comp.height = logicalH;
  const ctx  = comp.getContext('2d', { willReadFrequently: true });
  let prevImageData = null;
  const outs = [];

  frames.forEach((f, idx) => {
    const { left, top, width, height } = f.dims;
    const disposal = f.disposalType || 0; // 0/1 none, 2 bg, 3 previous
    if (disposal === 3) {
      try { prevImageData = ctx.getImageData(0, 0, logicalW, logicalH); } catch(_) { prevImageData = null; }
    }
    const patch = new ImageData(new Uint8ClampedArray(f.patch), width, height);
    ctx.putImageData(patch, left, top);

    const out = document.createElement('canvas'); out.width = logicalW; out.height = logicalH;
    out.getContext('2d').drawImage(comp, 0, 0);
    outs.push(out);

    if (disposal === 2) ctx.clearRect(left, top, width, height);
    else if (disposal === 3 && prevImageData) ctx.putImageData(prevImageData, 0, 0);

    onProgress && onProgress('compose', idx+1, frames.length);
  });
  return outs;
}

function downscale(canvas, maxW, maxH){
  const sw = canvas.width, sh = canvas.height;
  const scale = Math.min(maxW/sw, maxH/sh, 1);
  if (scale >= 1) return canvas;
  const dw = Math.max(1, Math.round(sw * scale));
  const dh = Math.max(1, Math.round(sh * scale));
  const out = document.createElement('canvas'); out.width = dw; out.height = dh;
  const ctx = out.getContext('2d');
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(canvas, 0, 0, dw, dh);
  return out;
}

/* Feathered black chroma key + defringe */
function chromaKeyBlackFeather(canvas, thr = 8, soft = 10, spill = 0.25) {
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const d = img.data, t0 = thr, t1 = thr + soft;

  for (let i = 0; i < d.length; i += 4) {
    const r = d[i], g = d[i+1], b = d[i+2], a0 = d[i+3];
    const m = Math.max(r, g, b);
    if (m <= t1) {
      const a = (m <= t0) ? 0 : Math.round(((m - t0) / (t1 - t0)) * a0);
      d[i+3] = a;
      if (a < a0 && spill > 0) {
        const gray = (r + g + b) / 3;
        d[i]   = Math.round(r * (1 - spill) + gray * spill);
        d[i+1] = Math.round(g * (1 - spill) + gray * spill);
        d[i+2] = Math.round(b * (1 - spill) + gray * spill);
      }
    }
  }
  ctx.putImageData(img, 0, 0);
}
function defringeAlphaEdges(canvas, passes = 1) {
  const w = canvas.width, h = canvas.height;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  for (let p = 0; p < passes; p++) {
    const img = ctx.getImageData(0, 0, w, h);
    const d = img.data; const copy = new Uint8ClampedArray(d);
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const i = (y * w + x) * 4, a = d[i + 3];
        if (a > 0 && a < 255) {
          let sr=0, sg=0, sb=0, c=0;
          for (let dy=-1; dy<=1; dy++){
            for (let dx=-1; dx<=1; dx++){
              if (!dx && !dy) continue;
              const j = ((y+dy)*w + (x+dx))*4;
              if (d[j+3] === 255){ sr+=d[j]; sg+=d[j+1]; sb+=d[j+2]; c++; }
            }
          }
          if (c){ copy[i]=Math.round(sr/c); copy[i+1]=Math.round(sg/c); copy[i+2]=Math.round(sb/c); }
        }
      }
    }
    img.data.set(copy); ctx.putImageData(img, 0, 0);
  }
}

/* Hash for dedupe */
function tinyHash(canvas){
  const s=16; const h=document.createElement('canvas'); h.width=s; h.height=s;
  const ctx=h.getContext('2d'); ctx.drawImage(canvas,0,0,s,s);
  return h.toDataURL('image/webp',0.5);
}

/* image-q quantization */
function quantizeCanvasInPlace(canvas, paletteSize=56){
  const ctx = canvas.getContext('2d');
  const img = ctx.getImageData(0,0,canvas.width,canvas.height);
  const pc = IQ.utils.PointContainer.fromUint8Array(img.data, canvas.width, canvas.height);
  const distance = new IQ.distance.Euclidean();
  const WuQ  = (IQ.quantization && IQ.quantization.WuQuant) || (IQ.image && IQ.image.quantization && IQ.image.quantization.WuQuant);
  const NeuQ = (IQ.quantization && IQ.quantization.NeuQuant) || (IQ.image && IQ.image.quantization && IQ.image.quantization.NeuQuant);
  const Quantizer = WuQ || NeuQ; if (!Quantizer) throw new Error('image-q quantizer not found');
  const quantizer = new Quantizer(distance, paletteSize);
  const palette = quantizer.quantize(pc);
  const Nearest = (IQ.image && IQ.image.NearestColor) || (IQ.image && IQ.image.nearestColor);
  if (!Nearest) throw new Error('image-q NearestColor not found');
  const mapper = new Nearest(distance);
  const apply  = IQ.applyPalette || (IQ.utils && IQ.utils.applyPalette);
  if (!apply) throw new Error('image-q applyPalette not found');
  const reducedPC = apply(pc, palette, mapper);
  const reduced = reducedPC.toUint8Array();
  ctx.putImageData(new ImageData(reduced, canvas.width, canvas.height), 0, 0);
}

/* Encoding helpers */
function canvasToDataURL(canvas, format, quality){
  if (format === 'webp') {
    return new Promise(res => canvas.toBlob(b => {
      const r = new FileReader(); r.onload = () => res(r.result);
      r.readAsDataURL(b);
    }, 'image/webp', quality));
  } else {
    return Promise.resolve(canvas.toDataURL('image/png'));
  }
}
async function autosizeQuality(frames, baseQuality, targetBytes, sampleCount=12){
  const idxs = []; const step = Math.max(1, Math.floor(frames.length / sampleCount));
  for (let i=0;i<frames.length; i+=step) idxs.push(i);
  if (idxs[idxs.length-1] !== frames.length-1) idxs.push(frames.length-1);
  let lo=0.1, hi=0.95, best=baseQuality, bestBytes=Infinity;
  for (let iter=0; iter<6; iter++){
    const mid = iter===0 ? baseQuality : (lo+hi)/2;
    let total = 0;
    for (const i of idxs){
      const url = await canvasToDataURL(frames[i], 'webp', mid);
      total += (url.length * 3/4);
    }
    const estBytes = (total / idxs.length) * frames.length;
    if (Math.abs(estBytes - targetBytes) < Math.abs(bestBytes - targetBytes)){ best = mid; bestBytes = estBytes; }
    if (estBytes > targetBytes) hi = mid; else lo = mid;
  }
  return Math.max(0.05, Math.min(0.95, best));
}

/* Decimation strategies */
function decimateToMaxFrames(canvases, delaysMs, maxCount){
  if (canvases.length <= maxCount) return { canvases, delaysMs };
  const keep = [], keepDelays = [];
  const step = Math.ceil(canvases.length / maxCount);
  let acc = 0;
  for (let i=0;i<canvases.length;i++){
    acc += delaysMs[i];
    if (i % step === 0) { keep.push(canvases[i]); keepDelays.push(acc); acc = 0; }
  }
  if (acc > 0 && keepDelays.length) keepDelays[keepDelays.length-1] += acc;
  return { canvases: keep, delaysMs: keepDelays };
}
function decimateToTargetFps(canvases, delaysMs, fps){
  const period = 1000 / fps;
  const keep = [], keepDelays = [];
  let acc = 0;
  for (let i=0;i<canvases.length;i++){
    acc += delaysMs[i];
    if (acc >= period){
      keep.push(canvases[i]);
      keepDelays.push(acc);
      acc = 0;
    }
  }
  if (acc > 0 && keepDelays.length) keepDelays[keepDelays.length-1] += acc;
  return { canvases: keep, delaysMs: keepDelays.length ? keepDelays : [period] };
}
function decimateEveryNth(canvases, delaysMs, n){
  if (n <= 1) return { canvases, delaysMs };
  const keep = [], keepDelays = [];
  let acc = 0;
  for (let i=0;i<canvases.length;i++){
    acc += delaysMs[i];
    if (i % n === 0) { keep.push(canvases[i]); keepDelays.push(acc); acc = 0; }
  }
  if (acc > 0 && keepDelays.length) keepDelays[keepDelays.length-1] += acc;
  return { canvases: keep, delaysMs: keepDelays };
}

async function gifToLottieSingleJSON(framesRaw, opts){
  const {
    logicalW, logicalH, maxW, maxH, frameMode, maxFrames, targetFps, keepNth,
    format, webpQ, targetKB, quantize, removeBlack, blackThresh, onProgress
  } = opts;

  // 1) Compose full logical frames with correct disposal handling
  const composed = composeGifFramesToCanvases(framesRaw, logicalW, logicalH, onProgress);

  // 2) Downscale + optional black removal (feathered) + defringe
  const resized = composed.map((c, i) => {
    const r = downscale(c, maxW, maxH);
    if (removeBlack) { chromaKeyBlackFeather(r, Math.max(0, blackThresh - 2), 10, 0.25); defringeAlphaEdges(r, 1); }
    onProgress && onProgress('resize', i+1, composed.length);
    return r;
  });

  // 3) Deduplicate consecutive identical frames
  const delaysMs = framesRaw.map(f => (f.delay || 10) * 10);
  const uniq = []; const uniqDelays = [];
  let last = null;
  resized.forEach((c, i) => {
    const h = tinyHash(c);
    if (h === last && uniq.length) { uniqDelays[uniqDelays.length-1] += delaysMs[i]; }
    else { uniq.push(c); uniqDelays.push(delaysMs[i]); last = h; }
  });
  onProgress && onProgress('dedupe');

  // 3.5) Decimation (auto or manual)
  let dec = { canvases: uniq, delaysMs: uniqDelays };
  if (frameMode === 'auto'){
    const totalMs = delaysMs.reduce((a,b)=>a+b,0);
    const desired = Math.min(maxFrames, Math.max(120, Math.round((totalMs/1000)*20))); // aim ~20fps but ≤ max
    dec = decimateToMaxFrames(uniq, uniqDelays, desired);
  } else if (frameMode === 'max'){
    dec = decimateToMaxFrames(uniq, uniqDelays, maxFrames);
  } else if (frameMode === 'fps'){
    dec = decimateToTargetFps(uniq, uniqDelays, targetFps);
    if (dec.canvases.length > maxFrames) dec = decimateToMaxFrames(dec.canvases, dec.delaysMs, maxFrames);
  } else if (frameMode === 'step'){
    dec = decimateEveryNth(uniq, uniqDelays, keepNth);
    if (dec.canvases.length > maxFrames) dec = decimateToMaxFrames(dec.canvases, dec.delaysMs, maxFrames);
  }
  const cappedFrames = dec.canvases;
  const cappedDelays = dec.delaysMs;
  onProgress && onProgress('cap');

  // 4) Optional quantization
  if (quantize) {
    for (let i=0; i<cappedFrames.length; i++){
      try { quantizeCanvasInPlace(cappedFrames[i], 56); } catch(e){}
      onProgress && onProgress('quant', i+1, cappedFrames.length);
    }
  }

  // 5) Auto-size quality (WebP)
  let finalQuality = webpQ;
  const targetBytes = targetKB > 0 ? targetKB * 1024 : 0;
  if (format === 'webp' && targetBytes > 0){
    finalQuality = await autosizeQuality(cappedFrames, webpQ, targetBytes);
  }

  // 6) Encode frames to data URLs
  const dataURLs = [];
  for (let i=0; i<cappedFrames.length; i++){
    const url = await canvasToDataURL(cappedFrames[i], format, finalQuality);
    dataURLs.push(url);
    onProgress && onProgress('encode', i+1, cappedFrames.length);
  }

  // 7) Assemble Lottie JSON
  onProgress && onProgress('assemble');
  const w = cappedFrames[0].width, h = cappedFrames[0].height;
  const fr = 30;
  const assets = []; const layers = [];
  let t = 0;

  for (let i=0;i<dataURLs.length;i++){
    const id = `img_${i}`;
    assets.push({ id, w, h, p: dataURLs[i], e: 1 });
    const ip = Math.round((t/1000)*fr);
    const op = Math.round(((t + cappedDelays[i])/1000) * fr);
    layers.push({
      ddd:0, ind:i+1, ty:2, refId:id,
      ks:{ o:{a:0,k:100}, r:{a:0,k:0}, p:{a:0,k:[w/2,h/2,0]}, a:{a:0,k:[w/2,h/2,0]}, s:{a:0,k:[100,100,100]} },
      ip, op, st:0, bm:0
    });
    t += cappedDelays[i];
  }

  return { v:"5.7.4", fr, ip:0, op: layers.length ? layers[layers.length-1].op : 0, w, h, nm:"GIF2Lottie (Embedded)", ddd:0, assets, layers };
}
</script>
</body>
</html>
