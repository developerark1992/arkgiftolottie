<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Animation Converter - GIF & Lottie</title>
<link rel="icon" type="image/png" href="favicon.png" />
<meta name="description" content="Convert between GIF, Lottie (JSON), and WebM with alpha transparency. All scripts self-hosted." />
<style>
  body { background:#121212; color:#e0e0e0; font-family:'Segoe UI',sans-serif; padding:2rem; margin:0; display:flex; justify-content:center; }
  .card { background:#1e1e1e; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.5); padding:2rem; width:90%; max-width:700px }
  h2,h3 { margin:0 0 1rem; color:#fafafa }
  .section { margin-bottom:1.5rem }
  input, button, select, label { font-size:1rem; margin-right:.5rem; margin-top:.3rem; }
  input[type="text"], input[type="number"], select {
    padding:.4rem; border-radius:4px; border:1px solid #555; background:#2b2b2b; color:#fff;
    vertical-align: middle;
  }
  button {
    background:#2196f3; border:none; border-radius:6px; color:#fff;
    cursor:pointer; padding:.6rem 1.2rem; transition:background .2s;
    vertical-align: middle;
  }
  button:disabled { background:#555; cursor:not-allowed }
  button:hover:not(:disabled) { background:#1976d2 }
  #progressContainer { display:none; margin:1rem 0 }
  #progressBar { width:100%; height:1rem }
  #status { margin-top:.5rem; text-align:center; font-size:.9rem }
  img, video, #lottieContainer {
    display:block; width:100%; margin:.5rem 0; border:1px solid #333;
    border-radius:6px; background:transparent;
  }
  #lottieContainer { height:300px; background:transparent }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap }
  .footer { margin-top:2rem; text-align:center; font-size:.9rem; color:#888 }
  .footer a { color:#2196f3; text-decoration:none }
</style>
</head>
<body>
<div class="card">
  <h2>Animation Converter - GIF & Lottie</h2>

  <div class="section row">
    <input type="file" id="fileInput" accept=".gif,.mp4,.webm,.json,.mov,.avi,.mkv" />
    <input type="text" id="fileNameInput" placeholder="Base filename" value="animation" />
  </div>

  <div class="section row">
    <label>Frames:
      <input type="number" id="frameCountInput" value="15" min="1" max="120" />
    </label>
    <label>Scale %:
      <input type="number" id="scaleInput" value="50" min="10" max="200" />
    </label>
    <label title="Only affects GIF export (GIF uses 1-bit transparency)">GIF Chroma Key:
      <select id="gifChromaSelect">
        <option value="#00FF00">#00FF00 (Green)</option>
        <option value="#FF00FF">#FF00FF (Magenta)</option>
        <option value="#FFFFFF">#FFFFFF (White)</option>
        <option value="#000000">#000000 (Black)</option>
      </select>
    </label>
  </div>

  <div class="section row">
    <button id="toGifBtn" disabled>Convert to GIF (1-bit alpha)</button>
    <button id="toLottieBtn" disabled>Convert to Lottie (transparent)</button>
    <button id="toVideoBtn" disabled>Convert to WebM (alpha)</button>
    <button id="resetBtn">Reset All</button>
  </div>

  <div id="progressContainer">
    <progress id="progressBar" max="100" value="0"></progress>
    <div id="status">Waiting…</div>
  </div>

  <div class="section">
    <h3>Preview</h3>
    <img id="gifPreview" style="display:none" alt="GIF Preview" />
    <video id="videoPreview" controls style="display:none; max-height:300px;"></video>
    <div id="lottieContainer" style="display:none"></div>
  </div>

  <div class="footer">
    Created by Abdul Rehman Khan —
    <a href="https://www.linkedin.com/in/developerark/" target="_blank" rel="noopener">LinkedIn Profile</a>
  </div>
</div>

<!-- UMD globals (no network): lottie + gif.js -->
<script src="./vendor/lottie-web/lottie.min.js"></script>
<script src="./vendor/gif.js/gif.min.js"></script>

<!-- App (ESM) -->
<script type="module">
  import { parseGIF, decompressFrames } from './vendor/gifuct-js/gifuct-esm.js';

  const lottie = window.lottie; // UMD global
  const GIF = window.GIF;       // UMD global

  const fileInput       = document.getElementById('fileInput');
  const fileNameInput   = document.getElementById('fileNameInput');
  const frameCountInput = document.getElementById('frameCountInput');
  const scaleInput      = document.getElementById('scaleInput');
  const gifChromaSelect = document.getElementById('gifChromaSelect');

  const toGifBtn        = document.getElementById('toGifBtn');
  const toLottieBtn     = document.getElementById('toLottieBtn');
  const toVideoBtn      = document.getElementById('toVideoBtn');
  const resetBtn        = document.getElementById('resetBtn');

  const progressWrap    = document.getElementById('progressContainer');
  const progressBar     = document.getElementById('progressBar');
  const statusText      = document.getElementById('status');

  const gifPreview      = document.getElementById('gifPreview');
  const videoPreview    = document.getElementById('videoPreview');
  const lottieContainer = document.getElementById('lottieContainer');

  const MAX_FILE_SIZE = 30 * 1024 * 1024; // 30MB
  const FPS = 30;

  let fileType = null, fileData = null, lottieData = null, gifFrames = null;

  function resetAll() {
    gifPreview.src = '';
    gifPreview.style.display = 'none';
    videoPreview.src = '';
    videoPreview.style.display = 'none';
    lottieContainer.innerHTML = '';
    lottieContainer.style.display = 'none';

    toGifBtn.disabled = true;
    toLottieBtn.disabled = true;
    toVideoBtn.disabled = true;

    progressWrap.style.display = 'none';
    progressBar.value = 0;
    statusText.textContent = 'Waiting…';

    fileType = null;
    fileData = null;
    gifFrames = null;
    lottieData = null;
  }

  fileInput.addEventListener('change', async () => {
    resetAll();
    const file = fileInput.files[0];
    if (!file) return;

    if (file.size > MAX_FILE_SIZE) {
      alert("File too large! Max 30 MB allowed.");
      fileInput.value = "";
      return;
    }

    const ext = file.name.split('.').pop().toLowerCase();
    fileType = ext;
    fileData = file;

    progressWrap.style.display = 'block';
    progressBar.value = 20;
    statusText.textContent = 'Uploading...';

    await new Promise(r => setTimeout(r, 150)); // small delay

    try {
      if (ext === 'gif') {
        gifPreview.src = URL.createObjectURL(file);
        gifPreview.style.display = 'block';
        toGifBtn.disabled = true;
        toLottieBtn.disabled = false;  // GIF -> Lottie (transparent)
        toVideoBtn.disabled = false;   // GIF -> WebM (alpha)

        const buf = await file.arrayBuffer();
        statusText.textContent = 'Processing GIF...';
        const parsed = parseGIF(buf);
        gifFrames = decompressFrames(parsed, true); // includes patch + dims

        progressBar.value = 100;
        statusText.textContent = 'Ready!';

      } else if (ext === 'json') {
        const jsonText = await file.text();
        lottieData = JSON.parse(jsonText);
        previewLottie(lottieData);

        toGifBtn.disabled = false;     // Lottie -> GIF (chroma)
        toLottieBtn.disabled = true;
        toVideoBtn.disabled = false;   // Lottie -> WebM (alpha)

        progressBar.value = 100;
        statusText.textContent = 'Ready!';

      } else if (['mp4','webm','mov','avi','mkv'].includes(ext)) {
        videoPreview.src = URL.createObjectURL(file);
        videoPreview.style.display = 'block';

        toGifBtn.disabled = false;    // will show backend-needed alert
        toLottieBtn.disabled = false; // will show backend-needed alert
        toVideoBtn.disabled = true;

        progressBar.value = 100;
        statusText.textContent = 'Video preview loaded. Video → GIF/Lottie conversion requires backend processing.';
      } else {
        alert('Unsupported file type');
        resetAll();
        return;
      }
    } catch (e) {
      console.error(e);
      alert('Failed to load file: ' + (e?.message || e));
      resetAll();
    }
  });

  // Auto-download helper
  function autoDownload(blob, filename) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // Utility: hex color -> number for GIF transparent (0xRRGGBB)
  function hexToNumber(hex) {
    const h = hex.replace('#','');
    return parseInt(h, 16) >>> 0;
  }

  // ---- Buttons ----

  // GIF → Lottie (transparent)
  toLottieBtn.addEventListener('click', async () => {
    try {
      if (fileType === 'gif' && gifFrames) {
        progressWrap.style.display = 'block';
        progressBar.value = 0;
        statusText.textContent = 'Building Lottie (transparent)...';

        const total = parseInt(frameCountInput.value, 10);
        const scale = parseFloat(scaleInput.value) / 100;

        const lottieJson = await buildLottieFromGif(gifFrames, total, scale, p => { progressBar.value = p * 100; });
        lottieData = lottieJson;

        previewLottie(lottieData);
        statusText.textContent = 'Lottie ready! Download starting...';

        const blob = new Blob([JSON.stringify(lottieJson, null, 2)], { type: 'application/json' });
        autoDownload(blob, (fileNameInput.value || 'animation') + '.json');

      } else if (['mp4','webm','mov','avi','mkv'].includes(fileType)) {
        alert('Video to Lottie conversion requires backend processing.');
      } else {
        alert('Please upload a GIF to convert to Lottie.');
      }
    } catch (e) {
      console.error(e);
      statusText.textContent = 'Error: ' + (e?.message || e);
      alert('Conversion failed: ' + (e?.message || e));
    }
  });

  // Lottie → GIF (1-bit alpha via chroma key)
  toGifBtn.addEventListener('click', async () => {
    try {
      if (fileType === 'json' && lottieData) {
        progressWrap.style.display = 'block';
        progressBar.value = 0;
        statusText.textContent = 'Rendering Lottie frames...';

        // Render frames with true alpha
        const rawFrames = await renderLottieToFrames(lottieData, parseInt(frameCountInput.value, 10));

        // Composite each frame over a chroma color (for 1-bit transparency in GIF)
        const chromaHex = gifChromaSelect.value;
        const chroma = hexToNumber(chromaHex);
        const gifFramesPrepared = prepareFramesForGif(rawFrames, chromaHex); // canvases

        statusText.textContent = 'Encoding GIF (1-bit alpha)...';

        const gif = new GIF({
          workers: 2,
          quality: 10,
          width: gifFramesPrepared[0].width,
          height: gifFramesPrepared[0].height,
          workerScript: './vendor/gif.js/gif.worker.js',
          transparent: chroma
        });

        gifFramesPrepared.forEach(f => gif.addFrame(f, { delay: 100 }));
        gif.on('progress', p => { progressBar.value = Math.round(p * 100); });
        gif.on('finished', blob => {
          gifPreview.src = URL.createObjectURL(blob);
          gifPreview.style.display = 'block';
          progressBar.value = 100;
          statusText.textContent = 'GIF ready! Download starting...';
          autoDownload(blob, (fileNameInput.value || 'animation') + '.gif');
        });

        gif.render();

      } else if (['mp4','webm','mov','avi','mkv'].includes(fileType)) {
        alert('Video to GIF conversion requires backend processing.');
      } else if (fileType === 'gif') {
        alert('You already have a GIF. Use Lottie or WebM export for transparency.');
      } else {
        alert('Please upload a Lottie JSON file to convert to GIF.');
      }
    } catch (e) {
      console.error(e);
      statusText.textContent = 'Error: ' + (e?.message || e);
      alert('Conversion failed: ' + (e?.message || e));
    }
  });

  // GIF/Lottie → WebM (VP9 with alpha)
  toVideoBtn.addEventListener('click', async () => {
    try {
      if ((fileType === 'gif' && gifFrames) || (fileType === 'json' && lottieData)) {
        progressWrap.style.display = 'block';
        progressBar.value = 0;
        statusText.textContent = 'Recording WebM (alpha)...';

        let framesToRecord;

        if (fileType === 'gif') {
          framesToRecord = await renderGifFramesToCanvas(gifFrames, parseInt(frameCountInput.value, 10)); // preserves alpha
        } else {
          framesToRecord = await renderLottieToFrames(lottieData, parseInt(frameCountInput.value, 10));  // preserves alpha
        }

        const videoBlob = await recordCanvasFramesToVideo(framesToRecord, FPS, p => {
          progressBar.value = p * 100;
        });

        if (videoBlob) {
          const videoUrl = URL.createObjectURL(videoBlob);
          videoPreview.src = videoUrl;
          videoPreview.style.display = 'block';
          autoDownload(videoBlob, (fileNameInput.value || 'animation') + '.webm');
          statusText.textContent = 'Video ready! Download starting...';
        } else {
          statusText.textContent = 'Video recording failed (codec not supported?).';
        }

      } else {
        alert('Upload a GIF or Lottie to convert to video.');
      }
    } catch (e) {
      console.error(e);
      statusText.textContent = 'Error: ' + (e?.message || e);
      alert('Conversion failed: ' + (e?.message || e));
    }
  });

  resetBtn.addEventListener('click', () => {
    fileInput.value = '';
    fileNameInput.value = 'animation';
    frameCountInput.value = 15;
    scaleInput.value = 50;
    resetAll();
  });

  // ---- Helpers ----

  function previewLottie(data) {
    lottieContainer.innerHTML = '';
    lottie.loadAnimation({
      container: lottieContainer,
      renderer: 'svg',
      loop: true,
      autoplay: true,
      animationData: data
    });
    lottieContainer.style.display = 'block';
    gifPreview.style.display = 'none';
    videoPreview.style.display = 'none';
  }

  // Build Lottie JSON from GIF frames (true alpha; correct patch handling)
  async function buildLottieFromGif(frames, total, scale, onProgress) {
    const origW = frames[0].dims.width, origH = frames[0].dims.height;
    const picks = Array.from({ length: total }, (_, i) => Math.floor(i * frames.length / total));
    const W = Math.floor(origW * scale), H = Math.floor(origH * scale);

    const canvas = document.createElement('canvas');
    canvas.width = W; canvas.height = H;
    const ctx = canvas.getContext('2d');

    const tmp = document.createElement('canvas');
    tmp.width = origW; tmp.height = origH;
    const tctx = tmp.getContext('2d');

    const images = picks.map((idx, i) => {
      const f = frames[idx];

      // Transparent base each frame
      tctx.clearRect(0, 0, origW, origH);

      // Correct patch handling
      const pw = f.dims.width, ph = f.dims.height;
      const px = f.dims.left, py = f.dims.top;
      const patchImage = new ImageData(new Uint8ClampedArray(f.patch), pw, ph);
      tctx.putImageData(patchImage, px, py);

      // scale into output canvas, preserve alpha
      ctx.clearRect(0, 0, W, H);
      ctx.drawImage(tmp, 0, 0, origW, origH, 0, 0, W, H);

      onProgress?.((i + 1) / total);
      return canvas.toDataURL('image/png'); // PNG with alpha
    });

    const assets = images.map((d, i) => ({
      id: `img_${i}`, w: W, h: H, p: d, e: 1
    }));

    const layers = images.map((_, i) => ({
      ddd: 0, ind: i + 1, ty: 2, refId: `img_${i}`,
      ks: {
        o: { a: 0, k: 100 }, r: { a: 0, k: 0 },
        p: { a: 0, k: [W / 2, H / 2, 0] },
        a: { a: 0, k: [W / 2, H / 2, 0] },
        s: { a: 0, k: [100, 100, 100] }
      },
      ip: i, op: i + 1, st: 0, bm: 0
    }));

    return {
      v: "5.7.4", fr: FPS, ip: 0, op: images.length,
      w: W, h: H, nm: "Transparent Lottie", ddd: 0,
      assets, layers
    };
  }

  // Render Lottie frames to canvases (preserve alpha)
  async function renderLottieToFrames(data, totalFrames) {
    return new Promise(resolve => {
      const frames = [];
      const W = data.w, H = data.h;
      const container = document.createElement('div');
      container.style.position = 'absolute';
      container.style.left = '-9999px';
      container.style.width = W + 'px';
      container.style.height = H + 'px';
      document.body.appendChild(container);

      const anim = lottie.loadAnimation({
        container: container,
        renderer: 'canvas',
        loop: false,
        autoplay: false,
        animationData: data
      });

      anim.addEventListener('DOMLoaded', () => {
        anim.goToAndStop(0, true);
        const step = anim.totalFrames / totalFrames;
        let i = 0;

        function grab() {
          if (i >= totalFrames) {
            anim.destroy();
            container.remove();
            return resolve(frames);
          }
          anim.goToAndStop(Math.floor(i * step), true);
          setTimeout(() => {
            const sourceCanvas = container.querySelector('canvas');
            const frameCanvas = document.createElement('canvas');
            frameCanvas.width = W;
            frameCanvas.height = H;
            const fctx = frameCanvas.getContext('2d');
            fctx.clearRect(0, 0, W, H);
            fctx.drawImage(sourceCanvas, 0, 0);
            frames.push(frameCanvas);
            i++;
            grab();
          }, 40);
        }
        grab();
      });
    });
  }

  // Render GIF frames to canvases (preserve alpha)
  async function renderGifFramesToCanvas(frames, totalFrames) {
    const origW = frames[0].dims.width, origH = frames[0].dims.height;
    const picks = Array.from({ length: totalFrames }, (_, i) => Math.floor(i * frames.length / totalFrames));

    const tmp = document.createElement('canvas');
    tmp.width = origW; tmp.height = origH;
    const tctx = tmp.getContext('2d');

    return picks.map(idx => {
      const f = frames[idx];

      // Build the full frame on a transparent temp canvas
      tctx.clearRect(0, 0, origW, origH);
      const pw = f.dims.width, ph = f.dims.height;
      const px = f.dims.left, py = f.dims.top;
      const patchImage = new ImageData(new Uint8ClampedArray(f.patch), pw, ph);
      tctx.putImageData(patchImage, px, py);

      // clone to a new canvas to freeze the frame
      const frameCanvas = document.createElement('canvas');
      frameCanvas.width = origW;
      frameCanvas.height = origH;
      frameCanvas.getContext('2d').drawImage(tmp, 0, 0);
      return frameCanvas;
    });
  }

  // Convert alpha frames to GIF-ready frames using chroma key fill
  function prepareFramesForGif(alphaFrames, hexColor) {
    return alphaFrames.map(src => {
      const c = document.createElement('canvas');
      c.width = src.width;
      c.height = src.height;
      const ctx = c.getContext('2d');

      // Fill with chroma color
      ctx.fillStyle = hexColor;
      ctx.fillRect(0, 0, c.width, c.height);

      // Draw the image on top (transparent pixels leave chroma showing)
      ctx.drawImage(src, 0, 0);
      return c;
    });
  }

  // Record canvas frames to WebM video blob (tries VP9 for alpha)
  async function recordCanvasFramesToVideo(frames, fps, onProgress) {
    return new Promise((resolve) => {
      if (!frames || !frames.length) return resolve(null);

      const canvas = document.createElement('canvas');
      canvas.width = frames[0].width;
      canvas.height = frames[0].height;
      const ctx = canvas.getContext('2d', { alpha: true });

      const stream = canvas.captureStream(fps);
      let mime = '';
      if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
        mime = 'video/webm;codecs=vp9';
      } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
        mime = 'video/webm;codecs=vp8';
      } else if (MediaRecorder.isTypeSupported('video/webm')) {
        mime = 'video/webm';
      } else {
        alert('MediaRecorder WebM not supported in this browser.');
        return resolve(null);
      }

      let recorder;
      try {
        recorder = new MediaRecorder(stream, { mimeType: mime });
      } catch (e) {
        console.error('MediaRecorder init failed:', e);
        alert('MediaRecorder not supported or codec unavailable.');
        return resolve(null);
      }

      const chunks = [];
      recorder.ondataavailable = e => { if (e.data && e.data.size > 0) chunks.push(e.data); };
      recorder.onstop = () => resolve(new Blob(chunks, { type: mime }));

      recorder.start();

      let i = 0;
      const total = frames.length;

      function drawFrame() {
        if (i >= total) {
          recorder.stop();
          return;
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(frames[i], 0, 0);
        i++;
        onProgress?.(i / total);
        setTimeout(drawFrame, 1000 / fps);
      }

      drawFrame();
    });
  }
</script>
</body>
</html>
