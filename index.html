<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ARK GIF ➜ Lottie (Single JSON)</title>
<style>
  :root { color-scheme: dark; }
  body { background:#121212; color:#e0e0e0; font-family:'Segoe UI',sans-serif; padding:2rem; margin:0; display:flex; justify-content:center; }
  .card { background:#1e1e1e; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.5); padding:2rem; width:90%; max-width:880px }
  h2,h3 { margin:0 0 1rem; color:#fafafa }
  .section { margin-bottom:1.25rem }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap }
  input, button, select, label { font-size:1rem; margin-right:.5rem; margin-top:.3rem; }
  input[type="text"], select, input[type="number"] {
    padding:.4rem; border-radius:6px; border:1px solid #555; background:#2b2b2b; color:#fff;
  }
  button {
    background:#2196f3; border:none; border-radius:8px; color:#fff; cursor:pointer;
    padding:.6rem 1.1rem; transition:background .2s;
  }
  button:disabled { background:#555; cursor:not-allowed }
  button:hover:not(:disabled) { background:#1976d2 }
  img, video, #lottieContainer {
    display:block; width:100%; margin:.5rem 0; border:1px solid #333; border-radius:8px;
  }
  #lottieContainer { height:320px; background:transparent }
  .hint { font-size:.9rem; color:#aaa }
</style>
</head>
<body>
<div class="card">
  <h2>ARK Animation Converter — Single JSON (GIF ➜ Lottie)</h2>

  <div class="section row">
    <input type="file" id="fileInput" accept=".gif" />
    <input type="text" id="fileNameInput" placeholder="Base filename" value="animation" />
  </div>

  <div class="section">
    <h3>Options</h3>
    <div class="row">
      <label>Embedded Format:
        <select id="embedFormat">
          <option value="webp">WebP (smaller)</option>
          <option value="png">PNG (larger / max compatibility)</option>
        </select>
      </label>
      <label>WebP Quality:
        <input type="number" id="webpQ" value="0.7" min="0" max="1" step="0.05" style="width:6rem" />
      </label>
    </div>
    <div class="row">
      <label>Max Width:
        <input type="number" id="maxW" value="512" min="16" step="1" style="width:6rem" />
      </label>
      <label>Max Height:
        <input type="number" id="maxH" value="512" min="16" step="1" style="width:6rem" />
      </label>
      <span class="hint">Downscale to fit box (keeps aspect ratio).</span>
    </div>
    <div class="row">
      <label><input type="checkbox" id="useQuant" checked /> Palette quantize before encode</label>
      <label><input type="checkbox" id="removeBlack" /> Remove black background</label>
      <label>Threshold <input type="number" id="removeBlackThresh" value="28" min="0" max="128" style="width:5rem" /></label>
    </div>
  </div>

  <div class="section row">
    <button id="toLottieBtn" disabled>Convert to single JSON</button>
  </div>

  <div class="section">
    <h3>Preview</h3>
    <div id="lottieContainer" style="display:none"></div>
  </div>

  <div class="hint">
    Tip: For the smallest JSON, use WebP + quantization + modest max size (e.g., 256–512 px).
  </div>
</div>

<script type="module">
import { parseGIF, decompressFrames } from 'https://esm.sh/gifuct-js@2.1.2';
import lottie from 'https://esm.sh/lottie-web';
import * as IQ from 'https://esm.sh/image-q@4.0.0';

const $ = id => document.getElementById(id);
const fileInput = $('fileInput');
const fileNameInput = $('fileNameInput');
const embedFormat = $('embedFormat');
const webpQ = $('webpQ');
const maxW = $('maxW');
const maxH = $('maxH');
const useQuant = $('useQuant');
const removeBlack = $('removeBlack');
const removeBlackThresh = $('removeBlackThresh');
const toLottieBtn = $('toLottieBtn');
const lottieContainer = $('lottieContainer');

let gifFrames = null;

fileInput.addEventListener('change', async () => {
  const f = fileInput.files[0];
  if (!f) return;
  if (f.size > 100*1024*1024) { alert('Max 100MB'); fileInput.value=''; return; }
  const buf = await f.arrayBuffer();
  gifFrames = decompressFrames(parseGIF(buf), true);
  toLottieBtn.disabled = !gifFrames;
});

toLottieBtn.addEventListener('click', async () => {
  if (!gifFrames) return;
  const opts = {
    format: embedFormat.value,      // 'webp' | 'png'
    webpQ: Math.max(0, Math.min(1, parseFloat(webpQ.value))),
    maxW: parseInt(maxW.value,10),
    maxH: parseInt(maxH.value,10),
    quantize: useQuant.checked,
    removeBlack: removeBlack.checked,
    blackThresh: parseInt(removeBlackThresh.value,10)
  };
  const json = await gifToEmbeddedLottie(gifFrames, opts);
  previewLottie(json);
  const name = (fileNameInput.value || 'animation') + '.json';
  downloadText(JSON.stringify(json, null, 2), name);
});

function previewLottie(data){
  lottieContainer.innerHTML = '';
  lottie.loadAnimation({ container: lottieContainer, renderer: 'svg', loop: true, autoplay: true, animationData: data });
  lottieContainer.style.display = 'block';
}

function downloadText(text, filename){
  const blob = new Blob([text], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
}

/* ===== Frame processing ===== */
function renderGifCanvases(frames){
  const w = frames[0].dims.width, h = frames[0].dims.height;
  const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h;
  const tctx = tmp.getContext('2d', { willReadFrequently:true });

  return frames.map(f=>{
    tctx.clearRect(0,0,w,h);
    tctx.putImageData(new ImageData(new Uint8ClampedArray(f.patch), f.dims.width, f.dims.height), f.dims.left, f.dims.top);
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d');
    ctx.drawImage(tmp,0,0);
    return c;
  });
}

function resizeCanvasFit(srcCanvas, maxW, maxH){
  const sw = srcCanvas.width, sh = srcCanvas.height;
  const scale = Math.min(maxW/sw, maxH/sh, 1);
  if (scale === 1) return srcCanvas;
  const dw = Math.max(1, Math.round(sw*scale));
  const dh = Math.max(1, Math.round(sh*scale));
  const c = document.createElement('canvas'); c.width = dw; c.height = dh;
  const ctx = c.getContext('2d');
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(srcCanvas, 0, 0, dw, dh);
  return c;
}

function applyChromaKeyBlack(canvas, threshold){
  const ctx = canvas.getContext('2d');
  const img = ctx.getImageData(0,0,canvas.width,canvas.height);
  const d = img.data;
  for(let i=0;i<d.length;i+=4){
    if (d[i] <= threshold && d[i+1] <= threshold && d[i+2] <= threshold) d[i+3] = 0;
  }
  ctx.putImageData(img,0,0);
}

/* Optional: image-q v4 quantization (safe) */
function quantizeCanvasInPlace(canvas, paletteSize=64){
  const ctx = canvas.getContext('2d');
  const img = ctx.getImageData(0,0,canvas.width,canvas.height);

  const pc = IQ.utils.PointContainer.fromUint8Array(img.data, canvas.width, canvas.height);
  const distance = new IQ.distance.Euclidean();
  const WuQ = (IQ.quantization && IQ.quantization.WuQuant) || (IQ.image && IQ.image.quantization && IQ.image.quantization.WuQuant);
  const NeuQ = (IQ.quantization && IQ.quantization.NeuQuant) || (IQ.image && IQ.image.quantization && IQ.image.quantization.NeuQuant);
  const QuantizerClass = WuQ || NeuQ;
  if (!QuantizerClass) throw new Error('image-q quantizer not found');

  const quantizer = new QuantizerClass(distance, paletteSize);
  const palette = quantizer.quantize(pc);

  const Nearest = (IQ.image && IQ.image.NearestColor) || (IQ.image && IQ.image.nearestColor);
  if (!Nearest) throw new Error('image-q NearestColor not found');

  const mapper = new Nearest(distance);
  const apply = IQ.applyPalette || (IQ.utils && IQ.utils.applyPalette);
  if (!apply) throw new Error('image-q applyPalette not found');

  const reducedPC = apply(pc, palette, mapper);
  const reduced = reducedPC.toUint8Array();
  ctx.putImageData(new ImageData(reduced, canvas.width, canvas.height), 0, 0);
}

/* tiny hash to merge identical consecutive frames */
function hashCanvas(canvas){
  const s=16;
  const c=document.createElement('canvas'); c.width=s; c.height=s;
  const ctx=c.getContext('2d'); ctx.drawImage(canvas,0,0,s,s);
  return c.toDataURL('image/webp',0.5);
}

/* ===== GIF ➜ Lottie (single JSON, embedded) ===== */
async function gifToEmbeddedLottie(framesRaw, opts){
  // 1) Build full frames
  const canvasesFull = renderGifCanvases(framesRaw);

  // 2) Downscale / remove black / quantize
  const canvases = canvasesFull.map(c => {
    const r = resizeCanvasFit(c, opts.maxW, opts.maxH);
    if (opts.removeBlack) applyChromaKeyBlack(r, opts.blackThresh);
    if (opts.quantize) {
      try { quantizeCanvasInPlace(r, 48); } catch(e){ console.warn('Quantization skipped:', e); }
    }
    return r;
  });

  // 3) Deduplicate consecutive identical frames
  const delays = framesRaw.map(f => (f.delay || 10) * 10); // ms
  const uniqueCanvases = [];
  const uniqueDelays = [];
  let lastHash = null;
  for (let i=0;i<canvases.length;i++){
    const h = hashCanvas(canvases[i]);
    if (h === lastHash && uniqueCanvases.length){
      uniqueDelays[uniqueDelays.length-1] += delays[i];
    } else {
      uniqueCanvases.push(canvases[i]);
      uniqueDelays.push(delays[i]);
      lastHash = h;
    }
  }

  // 4) Encode to data URLs (embedded)
  const w = uniqueCanvases[0].width, h = uniqueCanvases[0].height;
  const fr = 30; // logical framerate; timing comes from ip/op
  const layers = [];
  const assets = [];
  let t = 0;

  for (let i=0;i<uniqueCanvases.length;i++){
    const c = uniqueCanvases[i];
    let dataURL;

    if (opts.format === 'webp') {
      dataURL = await new Promise(res => c.toBlob(b => {
        const r = new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(b);
      }, 'image/webp', opts.webpQ));
    } else {
      dataURL = c.toDataURL('image/png'); // bigger but “like GIF”
    }

    const id = `img_${i}`;
    assets.push({ id, w, h, p: dataURL, e: 1 }); // embedded data URL

    const ip = Math.round((t/1000)*fr);
    const op = Math.round(((t+uniqueDelays[i])/1000)*fr);
    layers.push({
      ddd:0, ind:i+1, ty:2, refId:id,
      ks:{ o:{a:0,k:100}, r:{a:0,k:0}, p:{a:0,k:[w/2,h/2,0]}, a:{a:0,k:[w/2,h/2,0]}, s:{a:0,k:[100,100,100]} },
      ip, op, st:0, bm:0
    });
    t += uniqueDelays[i];
  }

  return { v:"5.7.4", fr, ip:0, op:layers.length ? layers[layers.length-1].op : 0, w, h, nm:"GIF2Lottie Embedded", ddd:0, assets, layers };
}
</script>
</body>
</html>
